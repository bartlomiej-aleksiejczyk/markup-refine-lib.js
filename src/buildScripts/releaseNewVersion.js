import { exec } from "child_process";
import fs from "fs";
import path from "path";
import { promisify } from "util";

const execAsync = promisify(exec);

async function execShellCommand(cmd) {
  try {
    const { stdout } = await execAsync(cmd);
    return stdout;
  } catch (error) {
    console.error("Execution error:", error);
    throw error.stderr;
  }
}

async function releaseNewVersion(versionType = "patch", customMessage = "") {
  try {
    const validTypes = ["major", "minor", "patch"];
    if (!validTypes.includes(versionType)) {
      throw new Error(`Invalid version type specified: ${versionType}. Use major, minor, or patch.`);
    }

    const packageJsonPath = path.join(process.cwd(), "package.json");
    const packageLockJsonPath = path.join(process.cwd(), "package-lock.json");
    const readmePath = path.join(process.cwd(), "README.md");
    const documentationPath = path.join(process.cwd(), "docs/", "index.html");

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
    const versionParts = packageJson.version.split(".").map((x) => parseInt(x, 10));

    switch (versionType) {
      case "major":
        versionParts[0] += 1;
        versionParts[1] = 0;
        versionParts[2] = 0;
        break;
      case "minor":
        versionParts[1] += 1;
        versionParts[2] = 0;
        break;
      case "patch":
        versionParts[2] += 1;
        break;
    }

    packageJson.version = versionParts.join(".");

    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    if (fs.existsSync(packageLockJsonPath)) {
      const packageLockJson = JSON.parse(fs.readFileSync(packageLockJsonPath, "utf8"));
      packageLockJson.version = packageJson.version;
      fs.writeFileSync(packageLockJsonPath, JSON.stringify(packageLockJson, null, 2));
    }

    const updateVersionInFile = (filePath, version) => {
      const content = fs.readFileSync(filePath, "utf8");
      const updatedContent = content.replace(
        /markup-refine-lib\.css@\d+\.\d+\.\d+/g,
        `markup-refine-lib.css@${version}`
      );
      fs.writeFileSync(filePath, updatedContent);
    };

    updateVersionInFile(readmePath, packageJson.version);
    updateVersionInFile(documentationPath, packageJson.version);

    const commitMessage = `
    Release ${versionType} version v${packageJson.version}
    
    Details:
    - Version Type: ${versionType}
    - New Version: v${packageJson.version}
    - Date: ${new Date().toLocaleString()}
    ${customMessage ? `- Notes: ${customMessage}` : ""}
    
    Generated by release script.
    `.trim();

    await execShellCommand(`git commit -am "${commitMessage}"`);
    await execShellCommand(`git tag v${packageJson.version}`);
    await execShellCommand("git push origin main --tags");

    console.log("Version released successfully:", packageJson.version);
  } catch (error) {
    console.error("Failed to release version:", error);
  }
}

const [, , versionType, customMessage] = process.argv;

releaseNewVersion(versionType, customMessage);
