import { exec } from "child_process";
import fs from "fs";
import path from "path";
import { promisify } from "util";

const execAsync = promisify(exec);

async function execShellCommand(cmd) {
  try {
    const { stdout } = await execAsync(cmd);
    return stdout;
  } catch (error) {
    console.error("Execution error:", error);
    throw error.stderr;
  }
}

const DIST_DIR = path.resolve("dist");

async function releaseNewVersion(versionType = "patch", customMessage = "") {
  try {
    const validTypes = ["major", "minor", "patch"];
    if (!validTypes.includes(versionType)) {
      throw new Error(
        `Invalid version type specified: ${versionType}. Use major, minor, or patch.`
      );
    }
    await execShellCommand("npm run build");
    await execShellCommand("git add dist/");

    const packageJsonPath = path.join(process.cwd(), "package.json");
    const packageLockJsonPath = path.join(process.cwd(), "package-lock.json");
    const readmePath = path.join(process.cwd(), "README.md");
    const documentationPath = path.join(process.cwd(), "docs/", "index.html");

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
    const versionParts = packageJson.version
      .split(".")
      .map((x) => parseInt(x, 10));

    switch (versionType) {
      case "major":
        versionParts[0] += 1;
        versionParts[1] = 0;
        versionParts[2] = 0;
        break;
      case "minor":
        versionParts[1] += 1;
        versionParts[2] = 0;
        break;
      case "patch":
        versionParts[2] += 1;
        break;
    }

    packageJson.version = versionParts.join(".");

    fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2));
    if (fs.existsSync(packageLockJsonPath)) {
      const packageLockJson = JSON.parse(
        fs.readFileSync(packageLockJsonPath, "utf8")
      );
      packageLockJson.version = packageJson.version;
      fs.writeFileSync(
        packageLockJsonPath,
        JSON.stringify(packageLockJson, null, 2)
      );
    }
    const readmeContent = fs.readFileSync(readmePath, "utf8");
    const updatedReadmeContent = readmeContent.replace(
      /markup-refine-lib\.js@\d+\.\d+\.\d+/g,
      `markup-refine-lib.js@${packageJson.version}`
    );
    fs.writeFileSync(readmePath, updatedReadmeContent);

    const documentationContent = fs.readFileSync(documentationPath, "utf8");
    const updatedDocumentationContent = documentationContent.replace(
      /markup-refine-lib\.js@\d+\.\d+\.\d+/g,
      `markup-refine-lib.js@${packageJson.version}`
    );
    fs.writeFileSync(documentationPath, updatedDocumentationContent);

    const commitMessage = `
    Release ${versionType} version v${packageJson.version}
    
    Details:
    - Version Type: ${versionType}
    - New Version: v${packageJson.version}
    - Date: ${new Date().toLocaleString()}
    ${customMessage ? `- Notes: ${customMessage}` : ""}
    
    Generated by release script.
    `.trim();

    await execShellCommand(`git commit -am "${commitMessage}"`);
    await execShellCommand(`git tag v${packageJson.version}`);
    await execShellCommand("git push origin main --tags");

    console.log("Version released successfully:", packageJson.version);
  } catch (error) {
    console.error("Failed to release version:", error);
  }
}

const [, , versionType, customMessage] = process.argv;

releaseNewVersion(versionType, customMessage);
